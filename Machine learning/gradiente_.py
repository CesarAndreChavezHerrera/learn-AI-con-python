# -*- coding: utf-8 -*-
"""gradiente .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hThFr6c-HOo2OeOwSfvy7V3lxAm8Xrre
"""

import numpy as np
import scipy as sc
import matplotlib.pyplot as plt

"""#deseson del gradiente

---

funcion a realizar 

---
$F(x,y) = sin( (1/2)X^{2} - (1/4)y^2 +3) cos(2x +1 -e^y)$
"""

#traducir esa formula

#funcion traducida a codigo func = lambda th: np.sin(1/2* x **2 - 1/4* y **2 + 3) *np.cos(2 *  x +1 - np.e ** y)
#funcion propia 
func = lambda th: np.sin(1/2 * th[0] **2 - 1/4*th[1]**2 + 3)* np.cos(2*th[0] + 1 - np.e**th[1])

#generar una vector para evaluar la funcion 
resolucion = 100
_x = np.linspace(-3,3,resolucion)

_y = np.linspace(-3,3,resolucion)

_z = np.zeros((resolucion,resolucion))

for index_x, x in enumerate(_x):

  for index_y, y in enumerate(_y):

    _z[index_y,index_x] = func([x,y])

"""mostrar los datos"""

plt.contourf(_x,_y,_z ,100)
plt.colorbar()
#crear el punto de origen
theta = np.random.random(2)*4-2

plt.plot(theta[0],theta[1],"o",c ="black")
plt.show()

"""ya trabajar para la mejorar de la funcion"""

plt.plot(theta[0],theta[1],"o",c = "black")
#derivada parcial 
_T = np.copy(theta)
h = 0.001
lr = 0.05

grad =np.zeros(2)

for _ in range(10000):
  for index_th , th in enumerate(theta):
    _T = np.copy(theta)
    _T[index_th] = _T[index_th] + h

    deriv = (func(_T)- func(theta))/ h
    grad[index_th] = deriv

  theta = theta -lr * grad

  #print(theta)
  if ( _ % 10 == 0):
    plt.plot(theta[0],theta[1],".",c = "red")


plt.contourf(_x,_y,_z ,100)
plt.colorbar()
plt.plot(theta[0],theta[1],"o",c = "yellow")
plt.show()